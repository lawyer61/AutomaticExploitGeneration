#-*- coding:utf-8 -*-


from AEGfunction import *
from AEGfunction import DangerousFunction 
from AEGinfo import *
from AEGcommon import * 
from AEGconfig import *
from AEGexceptions import *
from AEGInstruction import AEG_Instruction,AEG_GetDisplacement

from AEGagent import gdb_agent
from AEGframe import Getoffset_SP2BP

from idc import *
from idautils import *
from idaapi import * 


class ShadowMemItem(object):
	def __init__ (self , addr , length = 1):
		self.lb = addr 
		self.hb = addr + length - 1
	def __eq__(self , obj):
		return self.lb == obj.lb and self.hb == obj.hb
	def __le__ (self, obj):
		return self.lb <= obj.lb and self.hb <= obj.hb
	def __ge__ (self , obj):
		return self.lb >= obj.lb and self.hb >= obj.hb
	def __str__(self):
		return ''.join( str(i)+ ' ' for i in range(self.lb , self.hb+1)  )
	def __repr__(self):
		return self.__str__()
	def overlapItem(self,obj):
		return (self.lb <= obj.lb and self.hb >= obj.lb) or (self.lb <= obj.hb and self.hb >= obj.hb)
	def overlap(self, addr , length):
		return (self.lb <= addr and self.hb >= addr ) or (self.lb <= addr + length - 1 and self.hb >= addr + length - 1)
	def merge(self , obj):
		if self.hb + 1 == obj.lb :
			self.hb = obj.hb 
			return 1
		if self.lb == obj.hb + 1:
			self.lb = obj.lb
			return 1
		if self.lb <= obj.lb and self.hb >= obj.lb :
			self.hb = obj.hb
			return 2
		if self.lb <= obj.hb and self.hb >= obj.hb:
			self.lb = obj.lb
			return 2
		return 0

	def remove(self,addr , length = 1):
		'''
			删除指定地址和长度的item（脱色）
			注意这里可能会返回两个新的对象:
			
			(status , new_left_item , new_right_item)

			若status = 1 则删除成功，调用方应该删除本对象
			status = 0 删除失败
		'''
		if self.lb <= addr and self.hb >= addr + length - 1  :
			if self.lb < addr:
				left = ShadowMemItem(self.lb , length = addr - self.lb )
			else:
				left = None
			if  self.hb > addr + length - 1:
				right = ShadowMemItem(addr + length , length = self.hb - addr - length+1)
			else:
				right = None
			return (1 , left , right)

		else:
			return (0 , None , None)
class ShadowMem(object):
	def __init__(self):
		self.FrameMap = {"@abs_addr":[]}
		self.currentFrame = ''
		self.sorted = False
	def NewFrame(self, frame_name):
		if not self.FrameMap.has_key(frame_name):
			self.FrameMap[frame_name] = []
		self.currentFrame = frame_name
	
	def Sort(self):
		if self.sorted:
			return
		for key in self.FrameMap:
			self.FrameMap[key].sort()
	
	def Merge(self, frame_name , newitem):
		_merged_flag = False 
		for i in self.FrameMap[frame_name]:
			#print type( i)
			if i.merge(newitem):
				_merged_flag = True
				break
		if not _merged_flag:
			self.FrameMap[frame_name].append(newitem)

	def Remove(self, addr ,length , frame):
		for item in self.FrameMap[frame]:
			status , left , right =  item.remove(addr,length)
			if status:
				if left is not None: 
					self.Merge(frame , left)
				if right is not None : 
					self.Merge(frame , right)
				self.FrameMap[frame].remove(item)
				break
		pass

	def Taint(self , addr , length = 1, taint_type = 1, frame = None , status = 1):
		'''
		对给定地址染色。

		@addr: address to taint

		@taint_type: 1 = offset base on BP ; 2 = abs addr(e.g. 0x804a123) 

		@frame: if @taint_type == 1 , then use this frame name; if None, use self.frame_name(this corresponds to last call to NewFrame)

		'''
		printf("Shadow mem taint: %x length=%d frame=%s , status=%d" %(addr , length , str(frame) , status) , verbose = LOG_LEVEL_DEBUG)
		if taint_type == 1:
			if frame is None:
				_frame = self.currentFrame
			else:
				_frame = frame
		else:
			_frame = '@abs_addr'
		if status == 0:
			self.Remove(addr , length , _frame)
		else:
			self.sorted = False
			self.Merge(_frame , ShadowMemItem(addr , length))
		
	def Overlap(self , addr , length = 1 , frame_name = None ):
		'''
		可以用于检测是否有重叠，以及指定地址是否被染色。
		比如：
		
		ShadowMem.Overlap(-32) 检查 $bp - 32 是否被染色
		'''
		printf("Shadow Memory:addr = %d , length = %d , frame_name = %s " % (addr , length , str(frame_name)) , verbose=LOG_LEVEL_DEBUG)
		if frame_name is None:
			_frame = self.currentFrame
		else:
			_frame = frame_name
		for i in self.FrameMap[_frame]:
			if i.overlap(addr , length):
				return True
		return False 
	
	def OverlapAny(self, addr , length = 1):
		for frame_name in self.FrameMap:
			if frame_name != '@abs_addr' and self.Overlap(addr , length , frame_name= frame_name):
				return frame_name
		return None

	def __str__(self):
		ret = ''
		for key in self.FrameMap:
			ret += key + ':'
			ret += ''.join(str(i) for i in self.FrameMap[key])
			ret += '\n'
		return ret
	
	def ShowItems(self):
		'''
			以 addr:length的形式输出内容
		'''

		ret = ''
		for frame in self.FrameMap:
			ret += str(frame)
			for item in self.FrameMap[frame]:
				ret += '(%d)%x: length %d\t' %(item.lb , item.lb , item.hb - item.lb + 1)
			ret += '\n'
		return ret
class ShadowReg(object):

	reg_list_x64 = ['rax' , 'rbx' , 'rcx' , 'rdx' , 'rsi' , 'rdi' , 'rsp' , 'rbp']
	reg_list_x86 = ['eax' , 'ebx' , 'ecx' , 'edx' , 'esi' , 'edi' , 'esp' , 'ebp'] 
	reg_list_x16 = ['ax' , 'bx' , 'cx' , 'dx' , 'si' , 'di' , 'sp' , 'bp']
	reg_list_x8 =  ['al' , 'bl' , 'cl' , 'dl'] 
	def __init__(self):
		if INFO_BITS == 32:
			self.reglist = ShadowReg.reg_list_x86
		elif INFO_BITS == 64:
			self.reglist = ShadowReg.reg_list_x64
		
		self.reg = dict.fromkeys(
			self.reglist , 
			0
		)
	
	def GetRegNum(self , regname):
		if regname in ShadowReg.reg_list_x64:
			return 64 , ShadowReg.reg_list_x64.index(regname)
		elif regname in ShadowReg.reg_list_x86:
			return 32, ShadowReg.reg_list_x86.index(regname)
		elif regname in ShadowReg.reg_list_x16:
			return 16 ,ShadowReg.reg_list_x16.index(regname)
		elif regname in ShadowReg.reg_list_x8:
			return 8 , ShadowReg.reg_list_x8.index(regname)
		else:
			printf(regname , verbose=LOG_LEVEL_DEBUG)
			raise NotImplementedException()

	def Taint(self , regname , val = 1):
		self.reg[regname] = val 

	def Clear(self , regname):
		self.reg[regname] = 0
	
	def Set(self , regname , val):
		printf("Set Shadow reg value:%s=%d" % ( regname , val) , verbose = LOG_LEVEL_DEBUG)
		bits , regnum = self.GetRegNum(regname)
		_tmp = self.reg[self.reglist[regnum]]
		self.reg[self.reglist[regnum]] = ( (_tmp >> bits)<< bits)  + val
	def Get(self , regname):
		bits , regnum = self.GetRegNum(regname)
		return self.reg[self.reglist[regnum]] & ((1 << (bits)) - 1)

class TaintRecorder(object):

	def __init__(self):
		self.record = set()
	
	def addRecord(self , addr):
		printf("Add Record: %x" % addr , verbose = LOG_LEVEL_DEBUG)
		self.record.add(addr)
	def removeRecord(self , addr):
		self.record.discard(addr)
	def hasRecord(self, addr):
		return addr in self.record

class CallFlowItem(object):
	'''
		输出类函数有三种情况： 输出一个可以直接读的字符串(直接写到appendix里) ； 
				输出之前的被污染过的buf(appendix = 0?) ；
				输出与溢出无关的变量(appendix = None)
		输入类函数： 输入一个与溢出无关的变量（整数等）(忽略，可能是由scanf产生);
			输入触发了溢出(记录函数名和地址即可，由上层调用者判断是否溢出)
	'''


	def __init__(self , addr ,  classes = 0 ,func_name = None, appendix = None):
		'''
			classes: 0 = output a constant string 1 = input  2 = output  a buffer
		'''
		self.addr = addr
		self.classes = classes
		self.func_name = func_name
		self.appendix = appendix
	def __str__(self):
		return '%s:%s:%s:%x' % (self.classes , self.func_name , self.appendix, self.addr)

	def __repr__(self):
		return self.__str__()
	
	'''def __setattr__(self , attr ,value):
		setattr(self, attr , value)'''


def TranslateMem(addr  ,opnd , tp ):
	if tp == o_mem:
		try:
			return (2 , GetOperandValue(addr , 1))
		except :
			return (2 , GetOperandValue(addr , 0))
	_opnd = opnd.replace(']' , '').replace('[', '').strip('h')
	
	if tp == o_phrase:	
		if 'sp' in _opnd or 'bp' in _opnd :
			if '+' in _opnd or '-' in _opnd :
				displace = AEG_GetDisplacement(_opnd)
				return (1,displace )
			else:
				if 'sp' in _opnd:
					offset = Getoffset_SP2BP(addr)
					return (1, offset)
				else:
					return (1,0)
		else :
			raise NotImplementedException()
		return (1, )
	elif tp == o_displ:
		## displ 说明至少有一个数字可以提取
		
		reg = _opnd.split('+')[0]
		if 'sp' in reg or 'bp' in reg:
			displace = AEG_GetDisplacement(_opnd)
			if 'sp' in reg:
				offset = Getoffset_SP2BP(addr)
				return (1 , 0 - offset + displace)
			else :
				#offset = Getoffset_SP2BP(addr)
				return (1 , displace)
		else:
			raise NotImplementedException()
	else:
		printf("Translate mem: tp = %d" % tp)
		raise NotImplementedException()


def CallflowAnalysis(xref):
	'''
		对于某处溢出，检查其结构
	'''

	def _TraceBack(addr , reg):
		'''
			从给定地址向上回溯，一直到某个内存为止(stack var / data segment)
		'''
		_tmp_addr = addr
		func_head = AEG_GetFunctionHead(addr)
		while 1:
			_tmp_addr = idc.PrevHead(_tmp_addr)
			_tmp_addr_instr = AEG_Instruction(_tmp_addr)
			_op = _tmp_addr_instr.GetOperator()

			if _op in ('ret' , 'retn' , 'leave'):
				break
			elif _op == 'lea' and _tmp_addr_instr.GetOperand(0) == reg:
				if _tmp_addr_instr.IsStackVar(1):
					return _tmp_addr_instr.GetOperand(1)
				else:
					continue
			else:
				raise NotImplementedException()

			if func_head == _tmp_addr :
				break

	FunctionHead = AEG_GetFunctionHead(xref)
	_iter_addr = FunctionHead
	B_funcs = DangerousFunction('buffer')

	call_flow_record = []

	while 1:
		_iter_instr = AEG_Instruction(_iter_addr)
		_op = _iter_instr.GetOperator()

		#printf("Call flow checking : %x" % _iter_addr , verbose = LOG_LEVEL_DEBUG)
		if _op == 'call':
			refs_from = AEG_GetCodeXrefsFrom(_iter_addr)
			for ref in refs_from:
				_call_name = AEG_GetFuncName(ref)


				#### 输出函数
				if 'puts' in _call_name :
					arg = AEG_GetFuncArgs(_iter_addr)[0]
					_instr_arg = AEG_Instruction(arg)
					_op = _instr_arg.GetOperator()
					if _op == 'mov':
						###  mov dword ptr [esp] , xxx
						if _instr_arg.GetOpndType(1) == o_imm:
							cf = CallFlowItem(_iter_addr , classes = 0 , 
								func_name=_call_name , appendix=GetString(int(_instr_arg.GetOperand(1).strip('h'), base = 16)))
							call_flow_record.append(cf)
						elif _instr_arg.GetOpndType(1) == o_reg:
							_trace_reg = _instr_arg.GetOperand(1)
							_opnd = _TraceBack(arg , _trace_reg)
							cf = CallFlowItem(_iter_addr , classes = 2 , func_name = _call_name , appendix=_opnd)
							call_flow_record.append(cf)
						else:
							raise NotImplementedException()
					elif _op == 'push':
						#### push xxxx
						if _instr_arg.GetOpndType(0) == o_imm:
							cf = CallFlowItem(_iter_addr , classes = 0 , 
								func_name=_call_name , appendix=GetString(_instr_arg.GetOperand(0)))
							call_flow_record.append(cf)
						elif _instr_arg.GetOpndType(0) == o_reg:
							_trace_reg = _instr_arg.GetOperand(0)
							_opnd = _TraceBack(arg , _trace_reg)
							cf = CallFlowItem(_iter_addr , classes = 2 , func_name = _call_name , appendix=_opnd)
							call_flow_record.append(cf)
						else:
							raise NotImplementedException()
					elif _op == 'lea': 
						## lea rdi , [xxxx]
						raise NotImplementedException()
				elif 'putchar' in _call_name:
					_instr_arg = AEG_GetFuncArgs(_iter_addr)[0]
					_opnd = int(AEG_Instruction(_instr_arg).GetOperand(1).strip('h'), base=16)
					_opnd = chr(_opnd)
					cf = CallFlowItem(addr = _iter_addr , classes = 0 , appendix=_opnd , func_name=_call_name)
					call_flow_record.append(cf)
				elif 'printf' in _call_name:
					_instr_arg = AEG_Instruction(AEG_GetFuncArgs(_iter_addr)[0])
					if _instr_arg.GetOpndType(1) == o_imm:
						opnd_str = GetString(int(_instr_arg.GetOperand(1).strip('h'), base = 16))
						if opnd_str.count('%') != 0:
							opnd_str = opnd_str[:opnd_str.find('%')]
						cf = CallFlowItem(_iter_addr , classes = 0 , 
							func_name=_call_name , appendix=opnd_str)
						call_flow_record.append(cf)
					elif _instr_arg.GetOpndType(1) == o_reg:
						_trace_reg = _instr_arg.GetOperand(1)
						_opnd = _TraceBack(arg , _trace_reg)
						cf = CallFlowItem(_iter_addr , classes = 2 , func_name = _call_name , appendix=_opnd)
						call_flow_record.append(cf)
					elif _instr_arg.GetOperator() == 'push' and _instr_arg.GetOpndType(0) == o_imm:
						opnd_str = GetString(int(_instr_arg.GetOperand(0).strip('h'), base = 16))
						if opnd_str.count('%') != 0:
							opnd_str = opnd_str[:opnd_str.find('%')]
						cf = CallFlowItem(_iter_addr , classes = 0 , 
							func_name=_call_name , appendix=opnd_str)
						call_flow_record.append(cf)
						##TODO 
					else:
						raise NotImplementedException()

					pass
				elif 'write' in _call_name:
					raise NotImplementedException()



				#### 输入函数
				else:
					for func_obj in B_funcs:
						if func_obj.name == _call_name:
							cf = CallFlowItem( classes = 1 , addr = _iter_addr , func_name = func_obj.name)
							call_flow_record.append(cf)
							break
				
		elif _op in ('ret' , 'retn' , 'leave'):
			break
		
		_iter_addr = idc.next_head(_iter_addr)
	
	return call_flow_record

def StaticTaintAnalysis(xref , input_length , offset_BP):

	'''
		对于一处溢出，检查其染色情况
		@xref : addr of ' call _printf '
		@input_length: 
		@offset_BP: the offset from buffer head to BP 
	'''


	def CheckTaintStatus(addr ,  opnd , tp):
		if tp == o_reg:
			return sreg.Get(opnd)
		elif tp == o_imm:
			return 0
		
		memtype , memcont = TranslateMem(addr , opnd , tp)
		printf("check taint status:%d %d"% (memtype , memcont), verbose = LOG_LEVEL_DEBUG)
		if memtype == 1:
			return smem.Overlap(memcont)
		else :
			return smem.Overlap(memcont , frame_name ='@abs_addr')


	def SetTaintStatus(addr ,  opnd , tp , length = 1 ,status = 1):
		'''
			@status: 1 = taint , 0 = clear
			TODO: 染色长度
		'''

		if tp == o_reg:
			sreg.Set(opnd , status)
			return 1
		elif tp == o_imm:
			smem.Taint(int(opnd.strip('h') , base = 16) , taint_type=2 ,length = length ,status = status)
			return 1

		memtype , memcont = TranslateMem(addr , opnd , tp)
		
		smem.Taint(memcont , taint_type = memtype ,length = length ,status = status)

		return 1
	
	#####=================================


	smem = ShadowMem()
	sreg = ShadowReg()
	I_funcs = DangerousFunction('infect')
	smem.NewFrame(AEG_GetFuncName(AEG_GetFunctionHead(xref)))
	smem.Taint(offset_BP ,  input_length)
	recorder = TaintRecorder()
	## 从这个指令开始，染色

	_iter_addr = xref
	while True:
		_iter_addr = idc.next_head(_iter_addr)
		#printf("checking addr: %x "  % _iter_addr , verbose = LOG_LEVEL_DEBUG)
		_iter_instr = AEG_Instruction(_iter_addr)
		_op = _iter_instr.GetOperator()
		if _op == 'mov' or _op == 'lea':
			### 
			type1 = _iter_instr.GetOpndType(0)
			type2 = _iter_instr.GetOpndType(1)
			taint1 = CheckTaintStatus(_iter_addr , _iter_instr.GetOperand(0) , type1)
			taint2 = CheckTaintStatus(_iter_addr , _iter_instr.GetOperand(1) , type2)
			printf("addr : %x type1: %d type2: %d taint1:%s taint2:%s" %(_iter_addr , type1 , type2 , taint1, taint2 ) , verbose = LOG_LEVEL_DEBUG )
			if not taint1 and taint2:
				## 染色
				if SetTaintStatus(_iter_addr , _iter_instr.GetOperand(0) , type1 , status = 1):
					recorder.addRecord(_iter_addr)
			elif taint1 and not taint2:
				if SetTaintStatus(_iter_addr , _iter_instr.GetOperand(1) , type2 , status = 0):
					#recorder.addRecord(_iter_addr)
					pass
			elif taint1 and taint2:
				recorder.addRecord(_iter_addr)
		elif _op == 'call':
			
			#print sreg.reg
			
			## 针对该函数的所有参数进行检查。
			## args = AEG_GetFuncArgs(_iter_addr)
			refs_from = AEG_GetCodeXrefsFrom(_iter_addr)
			for ref in refs_from  :
				for ifunc in I_funcs:
					if AEG_GetFuncName(ref) == ifunc.name:
						## 找到了一个函数，可能会发生染色的传播
						args = AEG_GetFuncArgs(_iter_instr.addr)
						printf("find a infection function %x" % ref , verbose = LOG_LEVEL_DEBUG)
						arg_src  , arg_dst = args[ifunc.src_idx-1] , args[ifunc.dst_idx -1 ]
						if recorder.hasRecord(arg_src):
							### 在这类函数中，src和dst一定是以push lea 或者mov 来传递参数的
							### lea [esp] , memory addr
							### push imm
							### mov [esp] , imm
							_instr_dst = AEG_Instruction(arg_dst) 
							op_dst = _instr_dst.GetOperator()
							if op_dst == 'lea':
								raise NotImplementedException()
							elif op_dst == 'mov':
								if SetTaintStatus(arg_dst , _instr_dst.GetOperand(1) , _instr_dst.GetOpndType(1)):
									printf("Got Infected addr : %s" % (_instr_dst.GetOperand(1)))
									recorder.addRecord(_iter_instr.addr)
									printf(smem.ShowItems())
									break
							elif op_dst == 'push':
								raise NotImplementedException()
							else:
								raise NotImplementedException()
						else:
							printf("No taint record find in func %x" % _iter_addr , verbose = LOG_LEVEL_INFO)
						
						
			pass
		elif _op in ('ret' , 'leave' , 'retn'):
			break
		elif _op in ('add' , 'sub' , 'mul' , 'div','test'):
			pass
		elif 'j' in _op:
			printf("control flow changes.warning!" , verbose = LOG_LEVEL_DEBUG)
		elif _op == 'nop':
			pass
		elif _op == "push":
			pass
		else:
			printf(_op , verbose = LOG_LEVEL_DEBUG)
			raise NotImplementedException()
	
	return smem
