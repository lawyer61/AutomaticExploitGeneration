#-*- coding:utf-8 -*-
import sys

from idc import *
from idaapi import *
from idautils import *

from AEGconfig import *

from AEGcommon import printf
from AEGexceptions import *


def AEG_GetOperator(addr):
	'''
	返回一个指令的操作符(operator)

	@addr: the address of the instruction

	'''
	return GetMnem(addr).lower()

def AEG_GetOperand(addr , num):
	'''
	返回一个指令的第num个操作数(Operand)

	'''
	return GetOpnd(addr , num)

def AEG_GetOpndType(addr , idx):
	'''
	返回操作数的类型(the type fof operator)
	'''
	return GetOpType(addr , idx)

def AEG_AnalyseRefs(addr):
	'''
	给定一个地址，查看其引用的源头，可能是：
	
	1. call target ;
	2. lea Reg, target_address ;
	3. ..? TODO

	'''
	if GetMnem(addr).lower() == 'call':
		return 'call'
	raise NotImplementedException('Analyse Refs')


class AEG_Instruction(object):
	
	def __init__(self , addr):
		self.addr = addr
	def GetOperator(self):
		return AEG_GetOperator(self.addr)
	def GetOperand(self, num):
		return AEG_GetOperand(self.addr , num)
	def GetOpndType(self , idx):
		return AEG_GetOpndType(self.addr , idx)
	
	def GetStackVar(self,idx): ### For IDA toolkit
		'''
		Refernce : https://github.com/Somerset-Recon/blog/blob/master/vr_script_inline_strcpy.py
		'''
		def twos_compl(val, bits=32):
			'''compute the 2's complement of int value val'''
			if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
				val = val - (1 << bits)		# compute negative value
			return val
		
		#=========

		inst = DecodeInstruction(self.addr)
		# = ida_ua.decode_insn(self.addr)
		#print inst, inst[idx] , inst[idx].addr
		try:
			ret = get_stkvar(inst[idx] , inst[idx].addr)
		except :
			
			v = inst[idx].addr 
			if sys.maxint < v :
				import AEGinfo
				v = twos_compl(v, bits=AEGinfo.AEG_GetBits())
			#print(inst , inst[idx] ,v)
			ret = get_stkvar(inst , inst[idx] ,v)
		return ret 

if __name__ == "__main__":
	#printf(DecodeInstruction(0x804856f))
	pass
