#-*- coding:utf-8 -*-
from AEGconfig import *
from AEGexceptions import NotImplementedException
import idc
import idautils	
import AEGinfo
def printf(_format='' , end = '\n' , verbose = AEG_LOG_LEVEL , output_to_file = False,print_caller = True):
	if AEG_LOG_FILE < verbose:
		return 
	

	'''if verbose >= LOG_LEVEL_DEBUG and  print_caller:
		output = __name__ + ' ' + str(_format)
	else:'''
	
	output = str(_format)
	
	output = LOG_PREFIX[verbose] + output

	if PYTHON_VERTION == 2:
		if end == '':
			print output , 
		else :
			output += str(end)
			print output,
		if output_to_file:
			AEG_LOG_FILE.write(output)
	else :
		raise NotImplementedException("\n\nPython version not implement")

def AEG_GetCodeXrefsTo(addr , flow = 1):
	'''
	对于一个地址，返回针对引用到该地址的指令(仅限代码段)

	@flow : 是否使用正常的流分析
	'''
	return idautils.CodeRefsTo(addr , flow)

def AEG_GetCodeXrefsFrom(addr , flow = 1):
	'''
	获得从指定的指令出发的引用。
	在IDA套件中，这个操作将返回以下值： 本条指令的下一条地址 + 本条指令实际引用的部分。
	当这条指令是一个基本块的最后一条指令时，将没有第一项
	'''
	return idautils.CodeRefsFrom(addr , flow)

def AEG_save_file(filename , content , mode = "w"):
	'''
	保存至文件，比如shellcode，输出等
	'''

	with open(filename,  mode) as f:
		f.write(content)


class ScriptFiller(object):

	def __init__(self , processname = AEGinfo.INFO_INPUT_FILENAME , libc_path = AEGinfo.INFO_INPUT_LIBC):
		with open(os.path.join(CONFIG_DIR , "template.txt") ,'r') as f:
			self.content = f.read()
		self.processname = processname
		self.HackCode = ''
		self.AssistFunc = ''
		self.HackCodeTab = 1
		self.libc = libc_path
	def setProcessName(self,name):
		self.processname = name
	def addHackCode(self , code , moreTabs = 0):
		if moreTabs:
			self.HackCodeTab += moreTabs
		self.HackCode += (self.HackCodeTab * '\t' + code + '\n')
	def setHackCodeTabs(self, tabcnt):
		self.HackCodeTab += tabcnt
	def addAssistFunc(self , func):
		self.AssistFunc += func + '\n'
	def dump(self, filename = None):
		if filename is None:
			filename = AEGinfo.INFO_INPUT_FILENAME + ".atk.py"
		with open(filename , 'w') as f:
			f.write(self.GetContent())
		
	def GetContent(self):
		return self.content.format(process_name=self.processname ,
				assist_function=self.AssistFunc , 
				hack_code=self.HackCode,
				libc_path = self.libc
			)