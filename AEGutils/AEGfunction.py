#-*- coding:utf-8 -*-

from AEGcommon import printf
from AEGconfig import *
from AEGinfo import *
import idc
import idaapi 
import idautils
from idc import *
from AEGInstruction import AEG_Instruction

def AEG_GetAllFunctions():
	return idautils.Functions()

def AEG_GetFuncName(func_addr):
	return idc.GetFunctionName(func_addr)

def AEG_GuessArgs(addr):
	_iter_addr = addr
	ret = [] 
	while 1:
		_iter_addr = idc.prev_head(_iter_addr)
		_iter_instr = AEG_Instruction(_iter_addr)
		_op = _iter_instr.GetOperator()
		if _op in ('jmp' ,'call' , 'ret' , 'retn' , 'leave'):
			break 
		elif 'j' in _op:
			break
		elif _op == 'mov':
			_opnd0 = _iter_instr.GetOperand(0)
			if INFO_BITS == 32:
				## mov [esp+xx] , xxx
				if 'esp' in  _opnd0 and ']' in _opnd0:
					ret.append(_iter_addr)
			else:
				if 'di' in _opnd0 or 'si' in _opnd0 or 'dx' in _opnd0 or 'cx' in _opnd0:
					ret.append(_iter_addr)
		elif _op == 'push':
			ret.append(_iter_addr)
		elif 'lea' == _op :
			## lea rsi, xxx 
			_opnd0 = _iter_instr.GetOperand(0)
			if 'si' in _opnd0 or 'di' in _opnd0:
				ret.append(_iter_addr)

	return ret 
def AEG_GetFuncArgs(addr , num = None):
	args = idaapi.get_arg_addrs(addr)
	if args is None or len(args) == 0:
		args = AEG_GuessArgs(addr)
	if num is None:		
		return args
	return args[ num - 1 ]

def AEG_GetFunctionHead(addr):
	'''
	给定一个地址，得到这个地址所在的函数的开始地址
	'''
	return GetFunctionAttr(addr, idc.FUNCATTR_START)
	
def AEG_GetFunctionEnd(addr):
	return GetFunctionAttr(addr, idc.FUNCATTR_END)

def PrintFuncs(funcs,end = '\n'):
	_t = funcs
	#print(type(_t))
	if not isinstance(_t , (list,tuple) ) :
		_t = [_t]
	for tmp in _t :
		printf("%x - %s" % (tmp.addr, tmp.name) , end = end)


class DangerFuncsPreset(object):
	def __init__(self):
		from AEGconfig import DANGER_FUNCS_FILE ,WORKING_DIR
		import json , os
		_tpath = os.path.join( WORKING_DIR ,"config", DANGER_FUNCS_FILE)
		#printf("dangerous func file path:%s" % _tpath , verbose=LOG_LEVEL_DEBUG )
		with open( _tpath, 'r') as f:
			self.FUNCS = json.loads(f.read())
			if len(self.FUNCS) > 0 :
				printf("Load dangerous funcs successfully!" , verbose=LOG_LEVEL_DEBUG)
			else :
				printf("Load dangerous funcs failed" , verbose=LOG_LEVEL_ERR , output_to_file=True)
	def GetFuncs(self):
		return self.FUNCS
	
class DangerousFuncs(object) :
	def __init__(self, addr , func_name ,attr_dict):
		self.name = func_name
		self.addr = addr
		for i in attr_dict.keys():
			setattr(self , i , attr_dict[i])
	def __repr__(self):
		return "%x %s " % (self.addr , self.name)
	def __str__(self):
		return "%x %s " % (self.addr , self.name)

_Danger_funcs_preset = None

def DangerousFunction(type_constrain = None):
	ret= []
	global _Danger_funcs_preset
	if _Danger_funcs_preset is None:
		_Danger_funcs_preset = DangerFuncsPreset().GetFuncs()
	for func in AEG_GetAllFunctions():
		for key in _Danger_funcs_preset.keys():
			_func_name = AEG_GetFuncName(func)
			if _func_name == key : 
				if type_constrain :
					if _Danger_funcs_preset[_func_name]['type'] == type_constrain:
						ret.append(func)
				else:
					ret.append(func)
	if len(ret): 
		ret = list(set(ret))
		funcname_list = map(AEG_GetFuncName , ret)
		return map(DangerousFuncs , 
					ret , 
					funcname_list , 
					list(_Danger_funcs_preset[i] for i in funcname_list)
					)
	else :
		printf("No Danger funcs found in given binary." ,verbose=LOG_LEVEL_INFO)
		return ret