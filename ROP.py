#-*- coding:utf-8 -*-


from AEGutils.AEGfunction import * 
from AEGutils.AEGinfo import *
from AEGutils.AEGcommon import * 
from AEGutils.AEGconfig import *
from AEGutils.AEGexceptions import *
from AEGutils import AEGInstruction
from AEGutils.AEGbuffer import _DetectDangerFuncs
from AEGutils.AEGagent import gdb_agent
from AEGutils.AEGframe import Getoffset_SP2BP

from idc import *
from idautils import *
from idaapi import * 






def ROP_FindText():
	'''
	查找能在ret2text中利用到的代码
	如： system("/bin/sh") ; execve("/bin/sh" , NULL  , NULL)

	思路：先找出所有对.system的引用，然后对"call system"的指令分析其参数，如果参数里有'sh'那么就是找到了
	'''
	
	for func in AEG_GetAllFunctions():
		if AEG_GetFuncName(func) == '.system':
			xrefs = AEG_GetCodeXrefsTo(func)
			for xref in xrefs :
				if AEGInstruction.AEG_AnalyseRefs(xref) == 'call' :
					arg_cmd = AEG_GetFuncArgs(xref)[0]
					instr = AEGInstruction.AEG_Instruction(arg_cmd)
					_op = instr.GetOperator()
					if _op == "mov":
						### mov xxx [sp] , xxx
						try:
							cmd = GetString(GetOperandValue(arg_cmd ,1))
							if cmd == '/bin/sh' or cmd == '/bin/bash':
								### find a system('/bin/sh')
								return arg_cmd 
						except Exception as e:
							printf(e , verbose = LOG_LEVEL_DEBUG) 
					elif _op == "lea":
						pass
				else:
					raise NotImplementedException()
		elif '.exec' in AEG_GetFuncName(func):
			raise NotImplementedException()
		else:
			pass
	pass


class ShadowMemItem(object):
	def __init__ (self , addr , length = 1):
		self.lb = addr 
		self.hb = addr + length - 1
	def __eq__(self , obj):
		return self.lb == obj.lb and self.hb == obj.hb
	def __le__ (self, obj):
		return self.lb <= obj.lb and self.hb <= obj.hb
	def __ge__ (self , obj):
		return self.lb >= obj.lb and self.hb >= obj.hb
	def __str__(self):
		return ''.join( str(i)+ ' ' for i in range(self.lb , self.hb+1)  )
	def __repr__(self):
		return self.__str__()
	def overlapItem(self,obj):
		return (self.lb <= obj.lb and self.hb >= obj.lb) or (self.lb <= obj.hb and self.hb >= obj.hb)
	def overlap(self, addr , length):
		return (self.lb <= addr and self.hb >= addr ) or (self.lb <= addr + length - 1 and self.hb >= addr + length - 1)
	def merge(self , obj):
		if self.hb + 1 == obj.lb :
			self.hb = obj.hb 
			return 1
		if self.lb == obj.hb + 1:
			self.lb = obj.lb
			return 1
		if self.lb <= obj.lb and self.hb >= obj.lb :
			self.hb = obj.hb
			return 2
		if self.lb <= obj.hb and self.hb >= obj.hb:
			self.lb = obj.lb
			return 2
		return 0

	def remove(self,addr , length = 1):
		'''
			删除指定地址和长度的item（脱色）
			注意这里可能会返回两个新的对象:
			
			(status , new_left_item , new_right_item)

			若status = 1 则删除成功，调用方应该删除本对象
			status = 0 删除失败
		'''
		if self.lb <= addr and self.hb >= addr + length - 1  :
			if self.lb < addr:
				left = ShadowMemItem(self.lb , length = addr - self.lb )
			else:
				left = None
			if  self.hb > addr + length - 1:
				right = ShadowMemItem(addr + length , length = self.hb - addr - length+1)
			else:
				right = None
			return (1 , left , right)

		else:
			return (0 , None , None)
class ShadowMem(object):
	def __init__(self):
		self.FrameMap = {"@abs_addr":[]}
		self.currentFrame = ''
		self.sorted = False
	def NewFrame(self, frame_name):
		if not self.FrameMap.has_key(frame_name):
			self.FrameMap[frame_name] = []
		self.currentFrame = frame_name
	
	def Sort(self):
		if self.sorted:
			return
		for key in self.FrameMap:
			self.FrameMap[key].sort()
	
	def Merge(self, frame_name , newitem):
		_merged_flag = False 
		for i in self.FrameMap[frame_name]:
			#print type( i)
			if i.merge(newitem):
				_merged_flag = True
				break
		if not _merged_flag:
			self.FrameMap[frame_name].append(newitem)

	def Remove(self, addr ,length , frame):
		for item in self.FrameMap[frame]:
			status , left , right =  item.remove(addr,length)
			if status:
				if left is not None: 
					self.Merge(frame , left)
				if right is not None : 
					self.Merge(frame , right)
				self.FrameMap[frame].remove(item)
				break
		pass

	def Taint(self , addr , length = 1, taint_type = 1, frame = None , status = 1):
		'''
		对给定地址染色。

		@addr: address to taint

		@taint_type: 1 = offset base on BP ; 2 = abs addr(e.g. 0x804a123) 

		@frame: if @taint_type == 1 , then use this frame name; if None, use self.frame_name(this corresponds to last call to NewFrame)

		'''
		printf("Shadow mem taint: %x length=%d frame=%s , status=%d" %(addr , length , str(frame) , status) , verbose = LOG_LEVEL_DEBUG)
		if taint_type == 1:
			if frame is None:
				_frame = self.currentFrame
			else:
				_frame = frame
		else:
			_frame = '@abs_addr'
		if status == 0:
			self.Remove(addr , length , _frame)
		else:
			self.sorted = False
			self.Merge(_frame , ShadowMemItem(addr , length))
		
	def Overlap(self , addr , length = 1 , frame_name = None ):
		'''
		可以用于检测是否有重叠，以及指定地址是否被染色。
		比如：
		
		ShadowMem.Overlap(-32) 检查 $bp - 32 是否被染色
		'''
		if frame_name is None:
			_frame = self.currentFrame
		else:
			_frame = frame_name
		for i in self.FrameMap[_frame]:
			if i.overlap(addr , length):
				return True
		return False 
	
	def OverlapAny(self, addr , length = 1):
		for frame_name in self.FrameMap:
			if frame_name != '@abs_addr' and self.Overlap(addr , length , frame_name= frame_name):
				return frame_name
		return None

	def __str__(self):
		ret = ''
		for key in self.FrameMap:
			ret += key + ':'
			ret += ''.join(str(i) for i in self.FrameMap[key])
			ret += '\n'
		return ret
	
	def ShowItems(self):
		'''
			以 addr:length的形式输出内容
		'''

		ret = ''
		for frame in self.FrameMap:
			ret += str(frame)
			for item in self.FrameMap[frame]:
				ret += '(%d)%x: length %d\t' %(item.lb , item.lb , item.hb - item.lb + 1)
			ret += '\n'
		return ret
class ShadowReg(object):

	def __init__(self):
		if INFO_BITS == 32:
			self.reglist = ['eax' , 'ebx' , 'ecx' , 'edx' , 'esi' , 'edi' , 'esp' , 'ebp'] 
		elif INFO_BITS == 64:
			self.reglist = ['rax' , 'rbx' , 'rcx' , 'rdx' , 'rsi' , 'rdi' , 'rsp' , 'rbp'] 
		
		self.reg = dict.fromkeys(
			self.reglist , 
			0
		)
	
	def Taint(self , regname , val = 1):
		self.reg[regname] = val 

	def Clear(self , regname):
		self.reg[regname] = 0
	
	def Set(self , regname , val):
		printf("Set Shadow reg value:%s=%d" % ( regname , val) , verbose = LOG_LEVEL_DEBUG)
		self.reg[regname] = val
	def Get(self , regname):
		return self.reg[regname]

class TaintRecorder(object):

	def __init__(self):
		self.record = set()
	
	def addRecord(self , addr):
		printf("Add Record: %x" % addr , verbose = LOG_LEVEL_DEBUG)
		self.record.add(addr)
	def removeRecord(self , addr):
		self.record.discard(addr)
	def hasRecord(self, addr):
		return addr in self.record



def TranslateMem(addr  ,opnd , tp ):
	if tp == o_mem:
		return (2 , int(opnd , base = 16))
	_opnd = opnd.replace(']' , '').replace('[', '').strip('h')
	
	if tp == o_phrase:	
		if 'sp' in _opnd or 'bp' in _opnd :
			if '+' in _opnd or '-' in _opnd :
				displace = AEGInstruction.AEG_GetDisplacement(_opnd)
				return (1,displace )
			else:
				if 'sp' in _opnd:
					offset = Getoffset_SP2BP(addr)
					return (1, offset)
				else:
					return (1,0)
		else :
			raise NotImplementedException()
		return (1, )
	elif tp == o_displ:
		## displ 说明至少有一个数字可以提取
		
		reg = _opnd.split('+')[0]
		if 'sp' in reg or 'bp' in reg:
			displace = AEGInstruction.AEG_GetDisplacement(_opnd)
			if 'sp' in reg:
				offset = Getoffset_SP2BP(addr)
				return (1 , 0 - offset + displace)
			else :
				offset = Getoffset_SP2BP(addr)
				return (1 , offset)
		else:
			raise NotImplementedException()
	else:
		printf("Translate mem: tp = %d" % tp)
		raise NotImplementedException()

def StaticTaintAnalysis():


	def CheckTaintStatus(addr ,  opnd , tp):
		if tp == o_reg:
			return sreg.Get(opnd)
		elif tp == o_imm:
			return 0
		
		memtype , memcont = TranslateMem(addr , opnd , tp)
		printf("check taint status:%d %d"% (memtype , memcont), verbose = LOG_LEVEL_DEBUG)
		if memtype == 1:
			return smem.Overlap(memcont)
		else :
			return smem.Overlap(memcont , frame_name ='@abs_addr')


	def SetTaintStatus(addr ,  opnd , tp , length = 1 ,status = 1):
		'''
			@status: 1 = taint , 0 = clear
			TODO: 染色长度
		'''

		if tp == o_reg:
			sreg.Set(opnd , status)
			return 1
		elif tp == o_imm:
			smem.Taint(int(opnd.strip('h') , base = 16) , taint_type=2 ,length = length ,status = status)
			return 1

		memtype , memcont = TranslateMem(addr , opnd , tp)
		
		smem.Taint(memcont , taint_type = memtype ,length = length ,status = status)

		return 1
	
	#####=================================

	_tmp = _DetectDangerFuncs()
	if _tmp is not None:
		xref , input_length , offset_BP = _tmp 
	else:
		raise NotImplementedException()
	smem = ShadowMem()
	sreg = ShadowReg()
	I_funcs = AEG_GetDangerousFunctions('infect')
	smem.NewFrame(AEG_GetFuncName(AEG_GetFunctionHead(xref)))
	smem.Taint(0 - offset_BP ,  input_length)
	recorder = TaintRecorder()
	## 从这个指令开始，染色

	_iter_addr = xref
	while True:
		_iter_addr = idc.next_head(_iter_addr)
		#printf("checking addr: %x "  % _iter_addr , verbose = LOG_LEVEL_DEBUG)
		_iter_instr = AEGInstruction.AEG_Instruction(_iter_addr)
		_op = _iter_instr.GetOperator()
		if _op == 'mov' or _op == 'lea':
			### 
			type1 = _iter_instr.GetOpndType(0)
			type2 = _iter_instr.GetOpndType(1)
			taint1 = CheckTaintStatus(_iter_addr , _iter_instr.GetOperand(0) , type1)
			taint2 = CheckTaintStatus(_iter_addr , _iter_instr.GetOperand(1) , type2)
			printf("addr : %x type1: %d type2: %d taint1:%s taint2:%s" %(_iter_addr , type1 , type2 , taint1, taint2 ) , verbose = LOG_LEVEL_DEBUG )
			if not taint1 and taint2:
				## 染色
				if SetTaintStatus(_iter_addr , _iter_instr.GetOperand(0) , type1 , status = 1):
					recorder.addRecord(_iter_addr)
			elif taint1 and not taint2:
				if SetTaintStatus(_iter_addr , _iter_instr.GetOperand(1) , type2 , status = 0):
					#recorder.addRecord(_iter_addr)
					pass
			elif taint1 and taint2:
				recorder.addRecord(_iter_addr)
		elif _op == 'call':
			
			#print sreg.reg
			
			## 针对该函数的所有参数进行检查。
			## args = AEG_GetFuncArgs(_iter_addr)
			refs_from = AEG_GetCodeXrefsFrom(_iter_addr)
			for ref in refs_from  :
				for ifunc in I_funcs:
					if AEG_GetFuncName(ref) == ifunc.name:
						## 找到了一个函数，可能会发生染色的传播
						args = AEG_GetFuncArgs(_iter_instr.addr)
						printf("find a infection function %x" % ref , verbose = LOG_LEVEL_DEBUG)
						arg_src  , arg_dst = args[ifunc.src_idx-1] , args[ifunc.dst_idx -1 ]
						if recorder.hasRecord(arg_src):
							### 在这类函数中，src和dst一定是以push lea 或者mov 来传递参数的
							### lea [esp] , memory addr
							### push imm
							### mov [esp] , imm
							_instr_dst = AEGInstruction.AEG_Instruction(arg_dst) 
							op_dst = _instr_dst.GetOperator()
							if op_dst == 'lea':
								raise NotImplementedException()
							elif op_dst == 'mov':
								if SetTaintStatus(arg_dst , _instr_dst.GetOperand(1) , _instr_dst.GetOpndType(1)):
									printf("Got Infected addr : %s" % (_instr_dst.GetOperand(1)))
									recorder.addRecord(_iter_instr.addr)
									printf(smem.ShowItems())
									break
							elif op_dst == 'push':
								raise NotImplementedException()
							else:
								raise NotImplementedException()
						else:
							printf("No taint record find in func %x" % _iter_addr , verbose = LOG_LEVEL_INFO)
						
						
			pass
		elif _op in ('ret' , 'leave' , 'retn'):
			break
		else:
			raise NotImplementedException()
	
	return smem

if __name__ == "__main__":
	target_addr = ROP_FindText()
	if target_addr is None:
		pass
	smem = StaticTaintAnalysis()
	overflow_frame = smem.OverlapAny(INFO_BITS / 8 , length = INFO_BITS / 8)
	if overflow_frame is not None:
		printf("Find Return address tainted!" , verbose = LOG_LEVEL_DEBUG)
		printf(smem , verbose = LOG_LEVEL_DEBUG)
		started_offset =  sorted(smem.FrameMap[overflow_frame])[0].lb 
		print started_offset
	else:
		printf("No tainted addr found. Abort" , verbose = LOG_LEVEL_ERR)

	#StaticTaintAnalysis()